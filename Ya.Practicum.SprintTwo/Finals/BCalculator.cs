namespace Ya.Practicum.SprintTwo.Finals;

/// <summary>
/// Задание связано с обратной польской нотацией.
/// Она используется для парсинга арифметических выражений.
/// Еще её иногда называют постфиксной нотацией.
/// В постфиксной нотации операнды расположены перед знаками операций.<br />
/// <br />
/// Пример 1:<br />
///     3 4 +<br />
/// означает 3 + 4 и равно 7<br />
///<br />
/// Пример 2:<br />
///     12 5 /<br />
/// Так как деление целочисленное, то в результате получим 2.<br />
///<br />
/// Пример 3:<br />
///     10 2 4 * -<br />
/// означает 10 - 2 * 4 и равно 2<br />
/// ---------------------------------------------------------------------<br />
/// https://contest.yandex.ru/contest/22781/run-report/86800214/
/// ---------------------------------------------------------------------<br />
/// <br /><b> -- ПРИНЦИП РАБОТЫ -- </b><br />
/// Для решения задачи была исползована структура Стек (LIFO-очередь).
/// Стек работает следующим образом:
/// При добавлении элемента, он помещается на "верх" стека (операция Push(value)).
/// Получение данных происходит операцией Pop(). В результате возвращается значение с вершины стека,
/// а на самом стеке значение удаляется.
///
/// При последовательном проходе по заданному выражению проверяется,
/// является ли элемент оператором (метод IsOperator(s)).
/// Если элемент НЕ оператор, на вершину стека помещается числовое значение.
/// Если элемент оператор, с вершины стека считывается 2 операнда (left и right)
/// и совместно с оператором передаются методу ApplyOperator(left, right, op), в котором в зависимости от оператора
/// вычисляется значение подвыражения. Результат помещается на вершину стека.
///
/// Цикл выполняется до тех пор, пока не будет обработан последний элемент исходного выражения.
///
/// В результате на вершине стека оказывается искомый результат, который получается методом Pop().
///
/// <br /><b> -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ -- </b><br />
/// Корректность работы алгоритма обусловлена принципом работы стека.
/// При добавлении элемента, он помещяется на вершину стека.
/// При получении элемента со стека, берется элемент с вершины и удаляется со стека.
///
/// Пример:
/// Пусть выражение имеет вид: 10 2 4 * -
///
/// Так как первые три элемента выражения не являются операторами, они просто добавляются в стек последовательно.
/// Стек имеет вид: [4, 2, 10]. Вершиной стека является 4.
///
/// На 4 итерации цикла идет обработка оператора "*".
/// С вершины стека извлекается два операнда (4 и 2). Стек принимает вид: [10]. Вершина стека - 10.
/// Извлеченные операнды перемножаются (т.к. оператор - "*"), и результат помещается на вершину стека.
/// Стек принимает вид: [8, 10]. Вершина стека - 8.
///
/// На последней итерации (оператор "-"), с вершины стека извлекается два операнда (8 и 10). Стек пуст.
/// Результат выражения (10 - 8 = 2) помещается на вершину стека. Стек принимает вид [2]. Вершина стека - 2.
///
/// Так как в выражении не осталось элементов, на экран выводится значение с вершины стека - 2.
///
/// <br /><b> -- ВРЕМЕННАЯ СЛОЖНОСТЬ -- </b><br />
/// Временная сложность алгоритма складывается из составляющих этого алгоритма:
/// Цикл foreach - итерация по всем составляющим исходного выражения. Сложность - O(n)
///
/// Метод IsOperator() - Использует метод Enumerable.Contains, временная сложность которого O(n),
/// однако в данном случае данный метод будет работать за O(1), так как исходный IEnumerable - постоянный и не изменяется никогда.
///
/// Метод ApplyOperator(left, right, op) - Метод, который в зависимости от op выполняет какую либо операцию.
/// Сложность - O(1).
///
/// Операции стека Push(value) и Pop() выполняются за константное время - O(1).
///
/// Таким образом общая временная сложность алгоритма составляет O(n).
///
/// <br /><b> -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ -- </b><br />
/// Пространственная сложность алгоритма - O(n), так как происходит хранение операндов выражения на стеке.
/// </summary>
public static class BCalculator
{
    public static void Execute()
    {
        using var reader = new StreamReader(Console.OpenStandardInput());
        var expression = reader.ReadLine()!.Split(' ').ToList();
        var stack = new Stack<int>();

        foreach (var element in expression)
        {
            if (!IsOperator(element))
            {
                stack.Push(int.Parse(element));
                continue;
            }

            var right = stack.Pop();
            var left = stack.Pop();
            stack.Push(ApplyOperator(left, right, element));
        }

        using var writer = new StreamWriter(Console.OpenStandardOutput());
        writer.WriteLine(stack.Pop());
    }

    private static bool IsOperator(string s) => new[] {"+", "-", "*", "/"}.Contains(s);

    private static int ApplyOperator(int left, int right, string op) =>
        op switch
        {
            "+" => left + right,
            "-" => left - right,
            "*" => left * right,
            // ReSharper disable once PossibleLossOfFraction
            "/" => (int) Math.Floor((float)left / right),
            _ => throw new ArgumentException("Could not parse operator", nameof(op))
        };
}