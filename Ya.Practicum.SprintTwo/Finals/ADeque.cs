using Ya.Practicum.SprintTwo.DataStructures.Deque;

namespace Ya.Practicum.SprintTwo.Finals;

/// <summary>
/// Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом.
/// Методы push_back(x), push_front(x), pop_back(), pop_front() работали корректно.
/// Но, если в деке было много элементов, программа работала очень долго.
/// Дело в том, что не все операции выполнялись за O(1).
/// Помогите Гоше! Напишите эффективную реализацию.
/// ----------------------------------------------------------------<br />
/// https://contest.yandex.ru/contest/22781/run-report/86778941/
/// ----------------------------------------------------------------<br />
/// <br /><b> -- ПРИНЦИП РАБОТЫ -- </b><br />
/// В рамках данной задачи реализована структура - Дек.
/// Данная структура данных позволяет добавлять и удалять элементы как в начало, так и в конец дека.
///
/// Для достижения данных целей в структуре используется два указателя:
/// _head - указатель на начало дека;
/// _tail - указатель на конец дека.
///
/// В конструкторе структуры данных значение указателя _tail устанавливается на последний элемент массива.
/// Данная структура данных реализована на кольцевом буфере.
/// При выполнении одной из операций вставки и удаления указатель сдвигается.
///
/// При выполнении операции PushFront(value) - указатель _head сдвигается на единицу вперед (но не превосходя максимальную длинну массива).
/// При выполнении операции PushBack(value) - указатель _tail сдвигается на единицу назад (в пределах массива).
///
/// При выполнении операции PopFront() - указатель _head сдвигается на единицу назад (в пределах массива).
/// При выполнении операции PopBack() - указатель _tail сдвигается на единицу вперед (но не превосходя максимальную длинну массива).
///
/// В каждый момент времени указатели _head и _tail указывают на следующий свободный индекс начала и конца дека соотвественно.
///
/// <br /><b> -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ -- </b><br />
/// Корректность работы реализованной структуры данных достигается за счет использования указателей
/// на начало и конец дека.
///
/// При вызове каждого публичного метода дека происходит сдвиг опеределенного указателя.
/// Сдвивг указатеой просиходит таким образом, чтобы обеспечить "закольцовывание" массива.
/// Для этого к значению указателя добавляется необходимое значение (+1 или -1), а также максимальная длина дека
/// (полуаемая через конструктор), затем берется остаток от деления получившегося числа на максимальный размер дека.
/// Например, при максимальном размере дека = 3, при выполнении оперций PushFront(value) значение указателя
/// _head будет меняться так: 0 -> 1 -> 2 -> 0 -> 1 ...
///
/// Для указателя _tail действуют такие же правила, за исключением того, что данный указатель изменяется в обратном
/// (по отношению к _head) направлении.
///
/// <br /><b> -- ВРЕМЕННАЯ СЛОЖНОСТЬ -- </b><br />
/// За счет использования указателей на начало и конец дека временная сложность методов
/// разработанной структуры составляет O(1).
///
/// В каждом методе происходит установка/даление значение из массива по индексу со сложностью O(1),
/// а также сдвиг одного из указателей, который также выполяется за О(1).
///
/// Временная сложность алгоритма также зависит от количества выполняемых команд.
/// Таким образом общая временная сложность алгоритма составляет O(n).
///
/// <br /><b> -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ -- </b><br />
/// Пространственная сложность реализованной структуры данных составляет O(n).
/// Структура хранит 4 вспомогательных поля и один массив данных.
/// </summary>
public static class ADeque
{
    public static void Execute()
    {
        using var reader = new StreamReader(Console.OpenStandardInput());
        var commands = int.Parse(reader.ReadLine()!);
        var dequeue = new RingBufferDeque<int>(int.Parse(reader.ReadLine()!));

        for (var _ = 0; _ < commands; _++)
            ProcessCommand(dequeue, reader.ReadLine()!);
    }

    private static void ProcessCommand(RingBufferDeque<int> deque, string command)
    {
        var commandAndArg = command.Split(' ');
        try
        {
            string arg;
            switch (commandAndArg[0])
            {
                case "push_back":
                    arg = commandAndArg[1];
                    deque.PushBack(int.Parse(arg));
                    break;
                case "push_front":
                    arg = commandAndArg[1];
                    deque.PushFront(int.Parse(arg));
                    break;
                case "pop_back":
                    Console.WriteLine(deque.PopBack());
                    break;
                case "pop_front":
                    Console.WriteLine(deque.PopFront());
                    break;
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
    }
}