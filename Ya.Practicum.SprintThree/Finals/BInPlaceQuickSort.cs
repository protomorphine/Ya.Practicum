namespace Ya.Practicum.SprintThree.Finals;

/// <summary>
/// Тимофей решил организовать соревнование по спортивному программированию,
/// чтобы найти талантливых стажёров. Задачи подобраны, участники зарегистрированы,
/// тесты написаны. Осталось придумать, как в конце соревнования будет определяться победитель.
///
/// Каждый участник имеет уникальный логин. Когда соревнование закончится,
/// к нему будут привязаны два показателя:
/// количество решённых задач Pi и размер штрафа Fi.
/// Штраф начисляется за неудачные попытки и время, затраченное на задачу.
///
/// Тимофей решил сортировать таблицу результатов следующим образом:
/// при сравнении двух участников выше будет идти тот, у которого решено больше задач.
/// При равенстве числа решённых задач первым идёт участник с меньшим штрафом.
/// Если же и штрафы совпадают, то первым будет тот,
/// у которого логин идёт раньше в алфавитном (лексикографическом) порядке.
///
/// Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин.
/// В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки (англ. quick sort)
/// для таблицы результатов.
/// Так как Тимофей любит спортивное программирование и не любит зря расходовать
/// оперативную память, то ваша реализация сортировки не может потреблять O(n)
/// дополнительной памяти для промежуточных данных (такая модификация быстрой сортировки называется "in-place").
///
/// ===================================================================================================================
/// https://contest.yandex.ru/contest/23815/run-report/87564699/
/// ===================================================================================================================
/// -- ПРИНЦИП РАБОТЫ --
/// Для реализации данной задачи портебовалась реализация дополнительнйо структуры данных, представляющую
/// участника олимпиады.
/// Испольование данной структуры обусловлено наличием в среде .NET интерфейса IComparable{T},
/// который используется для сортировки объектов.
/// В реализации метода CompareTo представлен алгоритм сравнения, который расположит два объекта в правильном порядке.
///
/// Алгоритм сортировки реализован следующим образом:
/// 1) Выбирается опорный элемент.
/// 2) Элементы упорядочеваюстя относительно опорного.
/// 2.1) Элементы меньше опорного помещаются в левую часть списка (слева от опорного).
/// 2.2) Элементы больше опорного - справа от опорного.
/// 3) Рекрсивно сортируются два участка списка.
///
/// Принцип упорядовевания из ш.2:
/// Имеется два указателя (lPointer и rPointer), указывающих на начало и конец сортируемого участка соотвественно.
/// Элемент из начала списка сравнивается с опорным. Если он меньше - элемент остается на своем месте,
/// указатель lPointer увеличивается на единицу.
///
/// Тоже самое выполняется для элемента из конца списка (указатель rPointer). Если элемент больше опорного -
/// элемент остается на своем месте, а указатель уменьшается на единицу.
///
/// Если элемент слева больше, а элемент справа меньше опорного, меняем местами элементы на соотвествующих указателях.
/// Указатели при этом сдвигаем в необходимые стороны (lPointer + 1, rPointer - 1).
///
/// -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
///
/// На каждом уровне рекурсии будет выбран опорный элемент (середина переданного отрезка),
/// и левая и правая часть списка будет упорядочена относительно него.
/// Рекурсивные вызовы продолжаются до тех пор, пока начало сортируемого интервала не превзойдет конец.
/// В таком случае можно считать что последовательность отсортирована полностью. 
/// Благодаря этому можно считать что аогоритм работает корректно.
///
/// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
///
/// В усредненном случае алгоритм быстрой сортировки работает за O(N logN).
/// Однако возможно подобрать поледовательность, на который донный алгоритм будет выполнятся за O(N^2).
/// Это прежде всего связано с выбором опорного элемента; если опорный элемент - максимальный в последовательности,
/// глубина рекурсии будет равна N, при этом сама функция выплняет N операций, следовательно в таком случае алгоритм
/// выполнится за O(N^2).
/// 
/// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
///
/// Данынй алгоритм расходует дополнительную память на стек рекурсивных вызовов.
/// Пространственная сложность алгоритма O(logN).
/// </summary>
public static class BInPlaceQuickSort
{
    public static void Execute()
    {
        using var reader = new StreamReader(Console.OpenStandardInput());
        var participants = new List<Participant>();
        var count = int.Parse(reader.ReadLine()!);
        for (var i = 0; i < count; i++)
        {
            var data = reader.ReadLine()!.Split(' ');
            participants.Add(new Participant(data[0], int.Parse(data[1]), int.Parse(data[2])));
        }

        QuickSort(participants, 0, count - 1);

        foreach (var login in participants.Select(p => p.Login))
            Console.WriteLine(login);
    }

    /// <summary>
    /// Реализует быструю сортировку.
    /// </summary>
    /// <param name="arr">Список объектов.</param>
    /// <param name="left">Указатель на начало сортируемой последовательности.</param>
    /// <param name="right">Указатель на конец сортируемой последовательнсоти.</param>
    /// <typeparam name="T">Тип элемента в списке.</typeparam>
    private static void QuickSort<T>(IList<T> arr, int left, int right) where T : IComparable<T>
    {
        if (left > right)
            return;

        var pivot = arr[(left + right) / 2];

        var lPointer = left;
        var rPointer = right;

        while (lPointer <= rPointer)
        {
            if (arr[lPointer].CompareTo(pivot) < 0)
            {
                lPointer++;
                continue;
            }

            if (arr[rPointer].CompareTo(pivot) > 0)
            {
                rPointer--;
                continue;
            }

            (arr[lPointer], arr[rPointer]) = (arr[rPointer], arr[lPointer]);
            lPointer++;
            rPointer--;
        }

        QuickSort(arr, left, rPointer);
        QuickSort(arr, lPointer, right);
    }
}